#include <OpenKNX.h>
#include "SEN-UP1-8xTH.h"
#include <Logic.h>

#pragma message "Pico Core Version: " ARDUINO_PICO_VERSION_STR 

uint8_t mSerial2Active = false;

void appSetup(bool iSaveSupported);
void appLoop();

void setup()
{
    Serial1.setRX(KNX_UART_RX_PIN);
    Serial1.setTX(KNX_UART_TX_PIN);

    pinMode(DBGLED1, OUTPUT);
    digitalWrite(DBGLED1, HIGH);
    pinMode(DBGLED2, OUTPUT);
    digitalWrite(DBGLED2, HIGH);


    SERIAL_DEBUG.begin(115200);

    #if WAITFORSERIAL == 1
    bool toggle = false;
    while (!Serial)
    {
        digitalWrite(DBGLED2, toggle);
        digitalWrite(DBGLED1, !toggle);
        toggle = !toggle;
        delay(100);     // will pause until serial console opens
    }
    digitalWrite(DBGLED1, HIGH);
    digitalWrite(DBGLED2, HIGH);
    delay(1000);
    #elif WAITFORSERIAL == 2
    pinMode(WAITFORSERIAL_PIN, INPUT_PULLUP);
    bool toggle = false;
    while (!Serial && digitalRead(WAITFORSERIAL_PIN))
    {
        digitalWrite(DBGLED2, toggle);
        digitalWrite(DBGLED1, !toggle);
        toggle = !toggle;
        delay(100);     // will pause until serial console opens
    }
    digitalWrite(DBGLED1, HIGH);
    digitalWrite(DBGLED2, HIGH);
    delay(1000);
    #endif

    
    pinMode(PROG_LED_PIN, OUTPUT);
    digitalWrite(PROG_LED_PIN, HIGH);
    delay(DEBUG_DELAY);
    digitalWrite(PROG_LED_PIN, LOW);


  // pin or GPIO the programming led is connected to. Default is LED_BUILDIN
  knx.ledPin(PROG_LED_PIN);
  // is the led active on HIGH or low? Default is LOW
  knx.ledPinActiveOn(PROG_LED_PIN_ACTIVE_ON);
  // pin or GPIO programming button is connected to. Default is 0
  knx.buttonPin(PROG_BUTTON_PIN);
  // Is the interrupt created in RISING or FALLING signal? Default is RISING
  // knx.buttonPinInterruptOn(PROG_BUTTON_PIN_INTERRUPT_ON);

#ifdef USERDATA_SAVE_SIZE
  // utilize SaveRestore framework from knx-stack, this has to happen BEFORE knx.read()
  knx.setSaveCallback(Logic::onSaveToFlashHandler);
  knx.setRestoreCallback(Logic::onLoadFromFlashHandler);
#endif

  // all MAIN_* parameters are generated by OpenKNXproducer for correct version checking by ETS
  // If you want just a bugfix firmware update without ETS-Application dependency, just increase firmwareRevision.
  // As soon, as you want again a sync between ETS-Application and firmware, set firmwareRevision to 0.
  const uint8_t firmwareRevision = 0;
  OpenKNX::knxRead(MAIN_OpenKnxId, MAIN_ApplicationNumber, MAIN_ApplicationVersion, firmwareRevision);

  appSetup(SAVE_INTERRUPT_PIN);

  // start the framework.
  knx.start();
}

void loop()
{
  // don't delay here to much. Otherwise you might lose packages or mess up the timing with ETS
  knx.loop();

  appLoop();
}
